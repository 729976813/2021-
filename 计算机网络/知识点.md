[toc]



# 计算机网络

<img src="C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210128203829072.png" alt="image-20210128203829072" style="zoom:150%;" />

## 物理层

通信信道上的原始比特流传输，保证原始数据在物理媒体上传输。

### 1.信道复用技术

用公用信道传输信息。

![image-20210128144609759](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210128144609759.png)

#### 频分复用

用户被分配到一定的频带后，在通信过程中自始至终都占用这个频带。所有用户在同样的时间占用不同的带宽资源，这个带宽资源指的是频率贷款

#### 时分复用

时间片轮转法，每个用户只在分配的时间里使用线路传输数据

缺点：对信道的利用率不高，如果一个用户在自己的时间发送的数据少，其他用户还需要等待该用户的时间过去之后才能发送。

#### 统计时分复用

在每个要发送的数据上面做一个特殊的标记，给每个要发送的数据放入STDM帧中，让STDM帧带着数据发送过去，而接受的话，只需要分析STDM帧就行了。 

![image-20210128145312749](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210128145312749.png)

#### 波分复用

光的频分复用，每个用户占据一个波带。

## 数据链路层

物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用**差错检测、差错控制和流量控制**等方法，向网络层提供高质量的数据传输服务。数据链路层传输的是帧。

### 帧结构

EthernetII帧结构。有几种不同类型的帧结构，尽管它们格式和最大传输单元不同，但却能够共存于相同的物理媒体上。EthernetII 帧(又称DIX帧)是目前使用最广的以太帧。图21显示了Ethernet II帧结构(该帧前后的辅助字段没有显示)。与802.3以太帧结构相比，它较为简单。其中的以太类型字段标识了封装了该帧数据中的较高层协议。例如，以太类型值为0x0800指示了该帧包含了IPv4数据报，0x0806表明指示了该帧包含了ARP帧，0x8100指示了该帧包含了IEEE 802.1Q帧。

![image-20210201170028034](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210201170028034.png)

### 作用

1. 链路管理，帧同步
2. 流量控制，差错控制
3. 数据和控制信息分开
4. 透明传输和寻址

### 1.差错检测

 采用**循环冗余检验CRC**，CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。

网址：https://www.jianshu.com/p/7f4fd7f62de2

### 2.碰撞检测

**载波监听多点接入/碰撞检测（CSMA/CD）**：“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。

它的具体思想是：在发送之前先监听信道。如果介质空闲，则马上传输。如果介质正在忙，则一直监听到信道空闲，立刻传输。如果检测到冲突，那么立刻停止传输，等待一个随机的时间，之后再重复上面的步骤。

网址：https://blog.csdn.net/hanzhen7541/article/details/79018432

### 3.链路管理

两个结点要进行通信的时候，通信的双方必须要先交换一些必要的信息，建立一条数据链路，在传输数据的时候维持数据链路。数据链路的建立、维持和释放就叫做链路管理。

### 4.帧同步

在数据链路层，数据的传送单位是帧。数据一帧一帧地传送，就可以在出现差错时，将有差错的帧再重传一次，而避免了将全部数据都进行重传。帧同步指的是收方如何从收到的比特流中准确地区分出一帧的开始和结束。每个帧除了要传送的数据外，还包括校验码，以使接收方能发现传输中的差错。

### 5.流量控制

控制相邻两节点之间数据链路上的流量。流量控制实际上是对发送方数据流量的控制，使其发送率不致超过接收方所能承受的能力。这个过程需要通过某种反馈机制使发送方知道接收方是否能跟上发送方，也即需要有一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后继续发送。

更细节的在网址：https://blog.csdn.net/u011318735/article/details/17590265

## 网络层

![image-20210201205651282](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210201205651282.png)

交换机、路由器、网关

协议：IP，ICMP，ARP，RARP，IPX、RIP

### ipv4和ipv6的区别

| 描述     | IPv4                                                         | IPv6                                                         |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **地址** | 长度为 32 位（4 个字节）。地址由网络和主机部分组成，这取决于地址类。根据地址的前几位，可定义各种地址类：A、B、C、D 或 E。IPv4 地址的总数为 4 294 967 296。IPv4 地址的文本格式为 nnn.nnn.nnn.nnn，其中 0<=nnn<=255，而每个 n 都是十进制数。可省略前导零。最大打印字符数为 15 个，不计掩码。 | 长度为 128 位（16 个字节）。基本体系结构的网络数字为 64 位，主机数字为 64 位。通常，IPv6 地址（或其部分）的主机部分将派生自 MAC 地址或其他接口标识。根据子网前缀，IPv6 的体系结构比 IPv4 的体系结构更复杂。IPv6 地址的数目比 IPv4 地址的数目大 1028（79 228 162 514 264 337 593 543 950 336）倍。IPv6 地址的文本格式为 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中每个 x 都是十六进制数，表示 4 位。可省略前导零。可在地址的文本格式中使用一次双冒号（::），用于指定任意数目的 0 位。例如，::ffff:10.120.78.40 表示 IPv4 映射的 IPv6 地址。 |

| **地址生存期** | 通常，除使用 DHCP 分配的地址之外，此概念不适用于 IPv4 地址。 | IPv6 地址有两个生存期：首选生存期和有效生存期，而首选的生存期总是小于等于有效的生存期。首选生存期到期后，如果有同样好的首选地址可用，那么该地址便不再用作新连接的源 IP 地址。 有效生存期到期后，该地址不再用作入局信息包的有效目标 IP 地址或源 IP 地址。根据定义，某些 IPv6 地址有无限多个首选生存期和有效生存期，如本地链路（请参阅[地址作用域](https://www.ibm.com/support/knowledgecenter/zh/ssw_ibm_i_72/rzai2/rzai2compipv4ipv6.htm?view=kc#rzai2compipv4ipv6__compaddrscope)）。 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **地址前缀**   | 有时用于从主机部分指定网络。有时根据地址的表示格式写为 /nn 后缀。 | 用于指定地址的子网前缀。按照打印格式写为 /nnn（最多 3 位十进制数字，0 <= nnn <= 128）后缀。例如 fe80::982:2a5c/10，其中前 10 位组成子网前缀。 |

| **片段**    | 如果一个信息包对于要传送它的下一链路来说太大，那么可由发送方（主机或路由器）对其分段。 | 对于 IPv6，只能在源节点进行分段，且只能在目标节点完成重新装配。使用分段扩展报头。 |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **IP 报头** | 根据提供的 IP 选项，有 20-60 个字节的可变长度。              | 40 个字节的固定长度。没有 IP 报头选项。通常，IPv6 报头比 IPv4 报头简单。 |

| **最大传输单元（MTU）** | 链路的最大传输单元是特定链路类型（如以太网或调制解调器）支持的最大字节数。对于 IPv4，最小值一般为 576。 | IPv6 的 MTU 下限为 1280 个字节。也就是说，IPv6 不会在低于此极限时对信息包分段。要通过字节数小于 1280 的 MTU 链路发送 IPv6，链路层必须以透明方式对 IPv6 信息包进行分段及合并。 |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **路由信息协议（RIP）** | RIP 是路由守护程序支持的路由协议。                           | 目前，RIP 不支持 IPv6。                                      |

### ARP地址协议(也可属于网络层)

1. 每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系。
2. 主机（网络接口）**新加入网络时**（也可能只是mac地址发生变化，接口重启等）， 会发送免费ARP报文把**自己IP地址与Mac地址的映射关系广播给其他主机。**
3. 网络上的主机接收到免费ARP报文时，会更新自己的ARP缓冲区。将新的映射关系更新到自己的ARP表中。
4. 某个主机需要发送报文时，首先检查 ARP 列表中是否有对应 IP 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 ARP 数据包，该数据包包括的内容有：源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址等。
5. 当本网络的所有主机收到该 ARP 数据包时：

​       **（A）**首先检查数**据包中的 IP 地址是否是自己的 IP 地址**，如果**不是，则忽略该数据包。**

​       **（B****）**如果是，**则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖。**

​       **（****C\**）\**** 然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。

​     6.源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

代理ARP：当ARP请求目标跨网段时，网关设备收到此ARP请求、会将自己的MAC地址返回给请求者。

IPV6环境中已经没有ARP协议了。

#### ARP攻击

ARP欺骗攻击建立在局域网主机间相互信任的基础上的

当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？

此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b，

可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。

所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表

这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。

假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ＩＰ是１９２.１６８.０.１，我的硬件地址是ｍａｃ－ｃ，

此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。

ARP病毒攻击症状

 通常表现：-打开网页速度非常慢，甚至打不开

​         -提示IP地址冲突

​         -甚至导致校园网瘫痪断网

​         -一般会绑定木马病毒，窃取用户账号密码

**防御手段**

1. 手动监测

  网络管理员可以通过命令查看主机的ARP表或路由器的ARP表

  也可以用Sniffer工具进行抓包，查看可疑的<IP，MAC>地址映射

　2．动态监测

\- 被动监测 （ARP watch，ARP Guard）

  仅监测网路中是否存在ARP欺骗，不主动向外发送ARP报文

-主动监测（ARP防火墙）

 能够动态的监测局域网内针对本主机和针对网关的ARP欺骗，但如果配置错误，ARP防火墙会向局域网内发送大量的ARP报文，造成ARP报文的广播风暴，影响网络通信。

 在这里推荐一款查看局域网Mac地址和主机IP匹配显示的软件：Nbtscan  很好用网上也有使用说明，对于查找攻击主机很犀利、

-ARP双向绑定

  在pc端上 IP+mac 绑定

 在网络设备（交换路由）上 采用ip+mac+端口绑定

网关也进行IP和mac的静态绑定

-采用支持ARP过滤的防火墙

-建立DHCP服务器

  ARP攻击一般先攻击网关，将DHCP服务器建立在网关上

-划分安全区域

  ARP广播包是不能跨子网或网段传播的，网段可以隔离广播包。VLAN就是一个逻辑广播域，通过VLAN技术可以在局域网中创建多个子网，就在局域网中隔离了广播。。缩小感染范围。 但是，安全域划分太细会使局域网的管理和资源共享不方便。

### RARP工作原理

1）将源设备和目标设备的MAC地址字段都设为发送者的MAC地址和IP地址，发送主机发送一个本地的RARP广播，能够到达网络上的所有设备，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；  2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；  3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何的响应；  4） 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。

### ICMP协议

#### 功能

1. 确认IP包是否成功到达目标地址
2. 通知在发送过程中IP包被丢弃的原因

#### 注意

​	1. ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议

​	2. ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6

### RIP协议

RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。设备到与他直连网络的设备跳数为0，然后每经过一个三层设备跳数增加1，也就是度量值等于从本网络到达目网络间的三层设备数量，但并不等于所经过的网段数。

RIP通过UDP报文进行路由信息的交换，使用的端口号为520。所以它又是一个不可靠的路由协议

由于RIP的实现较为简单，在配置和维护管理方面也远比OSPF和IS-IS容易，因此RIP主要应用于规模较小的网络中，例如校园网以及结构较简单的地区性网络。对于更为复杂的环境和大型网络，一般不使用RIP协议。

RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。**由于这个限制，使得RIP不可能在大型网络中得到应用。**

#### OSPF协议

OSPF协议是一种链路状态路由协议。采用的是Dijkstra算法。

OSPF在刚开始建立的时候，需要进行区域洪泛，在区域边界建立选取一个指定路由器。选举规则是最高接口优先级的被选作指定路由器（DR），同时还会有一个备用指定路由器（BDR）会监控DR的状态，并在当前DR发生故障时接替其角色。

#### 路由器和交换机区别

路由器可以用来分割广播域，交换机不可以。

路由器工作在网络层，交换机工作在数据链路层。

路由器转发的依据是IP地址，交换机转发的依据是MAC地址。

路由器主要功能是将交换机组好的局域网连接起来。

交换机能做的，路由器都能做。

路由还可以提供防火墙的功能。

路由配置比交换机复杂。

路由器慢，交换机转发快。

## 传输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

#### 传输层协议

1. **传输控制协议 TCP**（Transmisson Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

#### TCP

传输控制协议TCP（Transmission Control protocol）是面向连接的，提供可靠交付，有拥塞控制，流量监控，通过双工通信，面向字节流（把应用层传下来的看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）。

##### 主要特点

1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；

2. 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；

3. TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；

4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；

5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

##### 首部格式

![image-20210202170918732](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210202170918732.png)

**序号**：对于字节流进行编号，例如序号为301，表示第一个字节的标号为301，如果携带的数据长度为100字节，那么下一个报文段的序号为401.

**确定号**：期望收到的下一个报文的序号，例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200字节，因此B期望下一个报文段的序号为701，B发送给A的确认报文段中的确认好为701.

**数据偏移**：指的是数据部分距离报文段起始的偏移量，实际上指的是首部长度。

**确认ACK**：当ACK=1时确认号确认号字段有效，否则无效。TCP规定，在连接建立后所传送的报文必须把ACK置1。

**同步SYN**：在连接建立时用来同步序号。当SYN=1，ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中SYN=1，ACK=1.

**终止FIN**：用来释放一个连接，当FIN=1，ACK=0时表示这是一个连接请求报文段，若对方同意建立连接，则响应报文中SYN=1，ACK=1

**窗口**：窗口作为接受方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

##### TCP如何保证可靠传输

- 校验和：TCP将保证他首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
- 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大可变小的滑动窗口协议。（TCP利用滑动窗口来进行流量控制）。
- 拥塞控制:当网络拥塞时，减少数据的发送（慢开始、拥塞避免、快重传、快恢复）。
- 停止等待协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后在发下一个分组。超时重传：当TCP发出一个段后，他启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

##### TCP三次握手

![image-20210202172337220](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210202172337220.png)

左边为客户端，右边为服务端：

- 首先服务端处于监听状态，等待客户的连接请求。
- 客户端主动打开，向服务端发送请求连接报文，SYN=1，ACK=0，选择一个初始的序号x（seq = x）。
- 服务端收到连接请求报文，如果同意建立连接，则向客户端发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个出事的序号y（seq=y）。
- 客户端收到服务端的连接确认报文后，还要向服务端发出确认，确认号为y+1，序号为x+1。
- 服务端收到客户端的确认后，连接建立。

##### 三次握手的原因

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不会进行三次握手，因此就不会在打开连接。

##### TCP四次挥手

![image-20210202173341991](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210202173341991.png)

左边为客户端，右边为服务端：（注：发起断开的可以是客户端，也可以是服务端）

- 第一次挥手，客户端发送连接释放报文，FIN=1.客户端进入FIN_WAIT_1状态，表示客户端没有数据再会发送给服务端（TCP属于于半关闭状态）。
- 第二次挥手，服务端接收到客户端发送到的FIN报文段（进入CLOSE_WAIT状态），发出确认（ACK，seq），此时服务端还能向客户端发送数据。客户端进入TIME_WAIT_2状态。
- 第三次挥手，当服务端不再需要连接时，服务端向客户端发送连接释放报文，FIN=1。同时服务端进入LAST-ACK状态。
- 第四次挥手，客户端收到发出的确认返回ACK，进入TIME-WAIT状态，等待2MSL（报文最大存活时间）后如果没有收到回复，则证明服务端已经正常关闭，则释放连接。服务端收到客户端的确认后释放连接。

##### 四次挥手的原因

客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入CLOSE_WAIT状态。这个状态是为了让服务器端发送还为传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。

四次挥手状态变化的解释：

> - FIN_WAIT_1:FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1的状态实际上是当socket在ESTABLISHED状态时，他想主动关闭连接，向对方发送FIN报文，此时该socket即将进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种状态，都会马上回应ACK报文，所以FIN_WAIT_1状态比较难遇到，而FIN_WAIT_2状态常常可以用netstat（可以列出系统上所有的网络套接字连接情况）看到。(主动方)
> - FIN_WAIT_2:在FIN_WAIT_2状态下的socket，表示半连接，也即有一方要求close连接，但另外还告诉另一方，在等等还有数据需要发送。（主动方）
> - CLOSE_WAIT:当收到对方的FIN报文后，系统回复ACK报文给对方，此时进入CLOSE_WAIT状态。接下来考虑的是，被动方是否还有数据需要传送，如果没有传送的话就可以关闭这个socket，发送FIN给对方，即关闭连接，所以在CLOSE_WAIT状态下需要完成的事情是等待去关闭连接。(被动方)
> - LAST_ACK：是被动关闭一方再发送FIN后等待对方最后的ACK报文。当收到ACK报文后，也既可以进入CLOSED可用状态。
> - TIME_WAIT：表示收到了对方的FIN报文，并发送处了ACK报文，就等2MSL后即可回到CLOSED可用状态。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可直接TIME_WAIT状态，无需FIN_WAIT_2。设置TIME_WAIT的两个理由：
>   1. 确保最后一个确认报文能够到达。如果B没有收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。
>   2. 等待一端时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
> - CLOSED：表示连接中断。

##### 三次握手与四次挥手面试中常见的问题

1.初始化连接SYN超时问题：

> - 在三次握手时，客户端发送SYN包给服务端以后就挂了，服务端回复SYN-ACK给服务端以后，一直没有收到客户端的ACK确认，这个时候连接既没有建立起来，也不能说是失败了。（这就需要一个超时时间来让server将连接断开），否则这个连接会一直占用server的SYN连接列中的一个位置，大量这样的连接就会将server的SYN队列耗尽，让正常的连接无法处理。
> - 目前linux系统中默认进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次重试间隔是前一次的双倍，5次的时间间隔为1s，2s,4s,8s,16s,总共31s,第5发出后还需要32s才知道第5次也超时了，所以总共要63s，由于SYN超时需要63s，那么就给了攻击者一个攻击服务器的机会，攻击者在短时间内把大量的SYN包发送给服务端（俗称SYN flood攻击），用于耗尽Server端的SYN队列。
> - 什么是SYN攻击：（SYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送SYN包，服务器回复确认包，并等待客户端的确认。由于原地址不存在，服务端需要不断地重发直至超时，这些伪造的SYN包长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络阻塞和系统瘫痪）。
> - 如何检测SYN攻击：
>   - 检测SYN攻击非常方便，当你在服务器中看到大量半连接的状态时，特别是原IP地址是随机的，基本上就可以断定是一次SYN攻击。在linux上使用系统自带的netstats命令来检测SYN攻击。
> - 如何防御SYN攻击：
>   - SYN攻击不能被完全阻止，除非TCP协议重新设计。我们所能做的是尽可能减轻SYN攻击的危害，常见的SYN攻击有以下几种：
>     - 缩短SYN的时间
>     - 增加最大连接次数
>     - 过滤网管防护（过滤网管首先要指明的防火墙，过滤网管防护首先要包罗超时设置，SYN网管和SYN署理三种）
>     - SYN cookies技术

2.如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，显然，客户端如果出现故障，服务端不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着关闭连接。

其余的在网址https://blog.csdn.net/qq_40760617/article/details/99714862

#### UDP

用户数据报协议UDP（User Datagram protocol）是无连接的，仅最大可能交付，没有拥塞控制，面向报文（对于应用传下来的报文不合并也不拆分，只添加UDP首部），支持一对一，一对多，多对一，多对多的交互通信。

##### 主要特点

1. UDP 是无连接的；

2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；

3. UDP 是面向报文的；

4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；

5. UDP 支持一对一、一对多、多对一和多对多的交互通信；

6. UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

##### 首部格式

![image-20210202170640367](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210202170640367.png)

首部字段只有8个字节，包括源端口、目的端口、长度、检验和。12字节的伪首部是为了计算校验和临时添加的。

#### 应用层

**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。\**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如\**域名系统 DNS**，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**等等。我们把应用层交互的数据单元称为报文。

##### 域名系统

域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

###### DNS解析原理

![image-20210202201242400](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210202201242400.png)

网址：https://network.51cto.com/art/202003/613009.htm

![image-20210203141935133](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210203141935133.png)

网址：https://www.jianshu.com/p/c856c95229fa

DNS采用的是UDP协议，因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。

在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 这种情况下，使用TCP协议。

因为TCP协议可靠性好啊！你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？

###### DNS负载均衡

相同的域名地址有多台服务器。因此，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。

 **DNS域名解析负载均衡有如下优点：**

> \1. 将负载均衡的工作交给DNS，省去了网站管理维护负载均衡服务器的麻烦。
>
> \2. 技术实现比较灵活、方便，简单易行，成本低，使用于大多数TCP/IP应用。
>
> \3. 对于部署在服务器上的应用来说不需要进行任何的代码修改即可实现不同机器上的应用访问。
>
> \3. 服务器可以位于互联网的任意位置。
>
> \4. 同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样就可以加速用户访问，改善性能。

  **同时，DNS域名解析也存在如下缺点：**

> \1. 目前的DNS是多级解析的，每一级DNS都可能缓存A记录，当某台服务器下线之后，即使修改了A记录，要使其生效也需要较长的时间，这段时间，DNS任然会将域名解析到已下线的服务器上，最终导致用户访问失败。
>
> \2. 不能够按服务器的处理能力来分配负载。DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态，所以其的负载均衡效果并不是太好。
>
> \3. 可能会造成额外的网络问题。为了使本DNS服务器和其他DNS服务器及时交互，保证DNS数据及时更新，使地址能随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。

 事实上，大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供服务的物理服务器，而是同样提供负载均衡服务器的内部服务器，这组内部负载均衡服务器再进行负载均衡，请请求发到真实的服务器上，最终完成请求。

##### DNS劫持

![image-20210203141147064](C:\Users\gavinyzhang\AppData\Roaming\Typora\typora-user-images\image-20210203141147064.png)

一种可能的域名劫持方式即黑客侵入了宽带路由器并对终端用户的本地DNS服务器进行篡改，指向黑客自己伪造的本地DNS服务器，进而通过控制本地DNS服务器的逻辑返回错误的IP信息进行域名劫持。

另一方面，由于DNS解析主要是基于UDP协议，除了上述攻击行为外，攻击者还可以监听终端用户的域名解析请求，并在本地DNS服务器返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。

##### DNS污染
我们知道在接收到域名解析请求时，本地DNS服务器首先会查找缓存，如果缓存命中就会直接返回缓存结果，不再进行递归DNS查询。这时候如果本地DNS服务器针对部分域名的缓存进行更改，比如将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。
##### 解决DNS劫持
DNS解析发生在HTTP协议之前，DNS解析和DNS劫持和HTTP没有关系，DNS协议使用的是UDP协议向服务器的53端口进行请求。
要想解决DNS劫持：

可以使用HttpDNS的方案：使用 HTTP协议向DNS服务器的80端口进行请求,来规避DNS劫持
比如：http://119.29.29.29/d?dn=domain&ip=clientIp
在终端上，可以更换DNS服务器，不管手机还是电脑，都能手动配置DNS

##### HTTP协议

HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。

默认HTTP的端口号为80，HTTPS的端口号为443。

###### HTTP1.0和HTTP1.1，HTTP2.0的区别

http1.0功能包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接，新建成本较高，并且开始时发送速率较慢（slow start）。

http1.1新增的功能

持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。

管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。以前，在同一个TCP连接里，先发送A请求，待服务器响应后，再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

Content-length字段的作用，声明本次回应的数据长度。在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。

分块传输编码：用Content-Length字段的条件是，服务器发送回应之前，须知道回应的数据长度。对于一些耗时的动态操作，这意味着服务器要等所有操作完成，才能发送数据。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。

1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。客户端请求的头信息新增了Host字段，用来指定服务器的域名。`Host: www.example.com `Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

1.1的问题：同一TCP连接里，所有的数据通信是按次序的。服务器一个个依次序处理请求。要是有回应特别慢，后面就会请求排队等着。这称为"队头堵塞"。两种方法：一是减少请求数，二是同时多开持久连接。

**HTTP1.0和HTTP1.1的区别**

（1）缓存处理：1.0中主要使用header里的If-Modified-Since,Expires做为缓存判断的标准，1.1引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

（2）带宽优化及网络链接的使用：1.0中，浪费带宽如客户端只需对象的一部分，服务器将整个对象发送过来，且不支持断点续传，1.1在请求头引入range头域，它**允许只请求资源的某个部分，即返回码是206**（Partial Content），方便了开发者自由的选择以便于充分利用带宽和连接。

（3）错误通知：1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

（4）**Host****头处理**：1.0认为每台服务器都绑定唯一IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。虚拟主机技术，在一台物理服务器上可存在多个虚拟主机（Multi-homed Web Servers）共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

（5）长连接，HTTP 1.1支持长连接和请求的流水线处理，一个TCP连接可传送多个请求和响应，减少了建立和关闭连接的消耗和延迟，默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

其余在网址：https://www.cnblogs.com/33debug/p/7387717.html

https://zhuanlan.zhihu.com/p/61423830也介绍了很多

###### HTTP 状态码分段以及对应出现的场景：

- 100-199 用于指定客户端相应的某些动作。
- 200-299 用于表示请求成功。
- 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。
- 400-499 用于指出客户端的错误。
- 500-599 用于指出服务器错误。

###### HTTP缓存控制

缓存控制四种方式

Cache-Control
Expires
Last-Modified
ETag
具体的在网址：https://www.jianshu.com/p/278e93e5b1fb

##### HTTPS通信流程

网址：https://zhuanlan.zhihu.com/p/56663184

##### session和cookie的区别，禁用cookie后怎么办

1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。
2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。
   所以，总结一下：
   Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
   Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

**不要混淆 session 和 session 实现。**

本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。

 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。

而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。

所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。

1. session 在服务器端，cookie 在客户端（浏览器）
2. session 默认被存在在服务器的一个文件里（不是内存）
3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4. session 可以放在 文件、数据库、或内存中都可以。
5. 用户验证这种场合一般会用 session

##### 常用协议的端口

TCP 21端口：FTP 文件传输服务

TCP 23端口：TELNET 终端仿真服务

TCP 25端口：SMTP 简单邮件传输服务

UDP 53端口：DNS 域名解析服务

TCP 80端口：HTTP 超文本传输服务

TCP 110端口：POP3 “邮局协议版本3”使用的端口

TCP 443端口：HTTPS 加密的超文本传输服务

##### GET和POST的区别

get用来获取数据，post用来提交数据

get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。

get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。

get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。

get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中.

**1.safe（安全）**

> 这里的安全和通常所理解的安全意义不同，就好比如果一个请求的语义本质上就是获取数据（只读），那么这个请求就是安全的。客户端向服务器发起的请求如果没有引起服务器端任何的状态变化，那么他就是安全的而post请求来提交数据必然会是服务器发生相应的变化。从这个维度来看，get请求相对服务器而言，是安全的，post则不安全的。

**ldempotend（幂等）**

> 幂等通俗的来讲就是指同一个请求执行多次和仅执行一次的效果完全相等。这里来扯出幂等主要是为了处理同一个请求重复发送的情况，假如在请求响应之前失去连接，如果这个请求时幂等的，那么就可以放心的重发一次请求。所以可以得出get请求时幂等的，可以重复发送请求，post请求时不幂等的，重复请求可能会发生无法预知的后果。

**cacheable（可缓存性）**

> 顾名思义，就是一个请求是否可以被缓存，绝大多数部分，post都是不可缓存的（某些浏览器可能支持post缓存），但get是可以缓存的。

##### DHCP协议

DHCP封包在传输层( Transport Layer）是采用UDP协议，而当Client传送给封包给Server时，采用的是UDP 68 Port，从Server传送给Client则是使用UDP 67 Port。

DHCP请求IP分配工作流程

网址：https://www.zyops.com/dhcp-working-procedure/

网址：https://blog.csdn.net/wuruixn/article/details/8282554

